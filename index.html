<!doctype html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8" />
    <title>x402 Worker Demo</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style>
      body{font-family: system-ui, -apple-system, Segoe UI, Roboto, PingFang SC, Noto Sans CJK, sans-serif; margin: 24px; line-height: 1.6;}
      code{background: #f6f6f6; padding: 0 4px; border-radius: 4px;}
      button{padding: 8px 14px; font-size: 14px; border-radius: 8px; border: 1px solid #ccc; cursor: pointer;}
      .box{border: 1px solid #e5e5e5; border-radius: 8px; padding: 16px; margin: 16px 0;}
      .muted{color:#777;}
      pre{white-space: pre-wrap;}
    </style>
  </head>
  <body>
    <h1>x402 å…¨æµç¨‹ï¼ˆGate Layerï¼‰æ¼”ç¤º</h1>

    <div class="box">
      <p>ç¬¬ä¸€è¡Œï¼ˆå…¬å¼€ï¼‰ï¼šHello x402 ğŸ‘‹</p>
      <p id="premium-line" class="muted">ç¬¬äºŒè¡Œï¼ˆä»˜è´¹åå¯è§ï¼‰ï¼šå°†åœ¨æ”¯ä»˜æˆåŠŸåæ˜¾ç¤ºâ€¦</p>
      <button id="unlock">ğŸ”“ è§£é”å®Œæ•´å†…å®¹ï¼ˆæµ‹è¯•ç½‘ GDOG 1ï¼‰</button>
    </div>

    <div id="log" class="box"><strong>æ—¥å¿—è¾“å‡ºï¼š</strong><pre id="out"></pre></div>
    <div class="box">
      <details>
        <summary>è¯´æ˜</summary>
        <ul>
          <li>è¯·åœ¨é’±åŒ…ä¸­åˆ‡æ¢è‡³ <strong>Gate Layer</strong> å¹¶å‡†å¤‡æµ‹è¯• GDOGï¼ˆåˆçº¦åœ°å€ï¼š<code>0xf6d9cf57e20ba0d33372e8998a9424aa53411e04</code>ï¼‰ã€‚</li>
          <li>æœ¬ demo ä½¿ç”¨ EIPâ€‘3009ï¼ˆ<code>TransferWithAuthorization</code>ï¼‰ç¦»çº¿ç­¾åï¼›ç”± facilitator ä»£ä»˜ gasã€æäº¤ä¸Šé“¾ã€‚</li>
        </ul>
      </details>
    </div>

<script>
const out = document.getElementById('out');
const premiumLine = document.getElementById('premium-line');
const unlockButton = document.getElementById('unlock');
const userWallet = '0xE45278e0Db93649E57d43CfA38c147c282841d5c';
const log = (...args) => { out.textContent += args.join(' ') + "\n"; };

// é’±åŒ…é”™è¯¯å¤„ç†è¾…åŠ©å‡½æ•°
function handleWalletError(e, operation) {
  if (e?.code === 4001) {
    return `æ‚¨å–æ¶ˆäº†${operation}æ“ä½œï¼Œå¯ä»¥é‡æ–°ç‚¹å‡»æŒ‰é’®é‡è¯•`;
  } else if (e?.code === -32002) {
    return 'é’±åŒ…å·²æœ‰å¾…å¤„ç†çš„è¯·æ±‚ï¼Œè¯·å…ˆåœ¨é’±åŒ…ä¸­å¤„ç†';
  } else if (e?.code === 4902) {
    return 'ç½‘ç»œæœªæ·»åŠ åˆ°é’±åŒ…ä¸­';
  }
  return e?.message || String(e);
}

// æ£€æµ‹é’±åŒ…ç±»å‹
function isRabbyWallet() {
  return window.ethereum?.isRabby === true;
}

// Rabby ä¸“ç”¨ï¼šå¤šæ¬¡é‡è¯•è¯·æ±‚
async function retryRequestForRabby(requestFn, operationType = 'æ“ä½œ', maxRetries = 3) {
  log(`   â³ Rabby å¿«é€Ÿ reject æ£€æµ‹åˆ°ï¼Œå°†å¤šæ¬¡é‡è¯•${operationType}...`);
  for (let i = 0; i < maxRetries; i++) {
    const waitTime = 2000 + (i * 1000);
    log(`   â†’ ç­‰å¾… ${waitTime / 1000} ç§’åè¿›è¡Œç¬¬ ${i + 1}/${maxRetries} æ¬¡é‡è¯•...`);
    await new Promise(resolve => setTimeout(resolve, waitTime));
    try {
      log(`   â†’ æ­£åœ¨é‡è¯•${operationType}ï¼ˆç¬¬ ${i + 1} æ¬¡ï¼‰...`);
      const result = await requestFn();
      log(`   âœ… é‡è¯•æˆåŠŸï¼`);
      return result;
    } catch (retryErr) {
      if (retryErr?.code === 4001) {
        log(`   âš ï¸ ç¬¬ ${i + 1} æ¬¡é‡è¯•ä»æ”¶åˆ° 4001 é”™è¯¯`);
        if (i === maxRetries - 1) {
          log(`   âŒ å·²é‡è¯• ${maxRetries} æ¬¡ï¼Œç”¨æˆ·å¯èƒ½çœŸçš„å–æ¶ˆäº†æ“ä½œ`);
          throw retryErr;
        }
      } else {
        throw retryErr;
      }
    }
  }
  throw new Error(`é‡è¯• ${maxRetries} æ¬¡åä»å¤±è´¥`);
}

// å»¶è¿Ÿé”™è¯¯å¤„ç†ï¼šç»™é’±åŒ…å¼¹çª—è¶³å¤Ÿçš„æ˜¾ç¤ºæ—¶é—´ï¼ˆç‰¹åˆ«é’ˆå¯¹ Rabbyï¼‰
async function walletRequestWithGracefulError(requestFn, operationType = '') {
  try {
    return await requestFn();
  } catch (e) {
    if (e?.code === 4001 && operationType && isRabbyWallet()) {
      try {
        return await retryRequestForRabby(requestFn, operationType, 3);
      } catch (retryErr) {
        throw e;
      }
    }
    throw e;
  }
}

async function fetchPaymentRequirements() {
  const r = await fetch('/content', { method: 'GET' });
  log('â† /content é¦–æ¬¡å“åº”çŠ¶æ€ï¼š', r.status);
  if (r.status === 404) {
    log('âŒ æœåŠ¡å™¨è¿”å›404ï¼Œ/contentç«¯ç‚¹ä¸å­˜åœ¨');
    log('ğŸ’¡ è¯·æ£€æŸ¥æœåŠ¡å™¨æ˜¯å¦æ­£ç¡®é…ç½®/contentè·¯ç”±ï¼Œæˆ–å°è¯•ä½¿ç”¨å®Œæ•´URLï¼ˆå¦‚http://your-server.com/contentï¼‰');
    throw new Error('æœåŠ¡å™¨æœªæ‰¾åˆ°/contentç«¯ç‚¹');
  }
  if (r.status !== 402) {
    const body = await r.text();
    log('âš ï¸ æœªè¿”å› 402ï¼Œç›´æ¥å¾—åˆ°ï¼š', body.slice(0, 200));
    return { response: r, requirements: null };
  }
  const body = await r.json();
  const reqs = body.accepts?.[0];
  if (!reqs) throw new Error('æ— æœ‰æ•ˆçš„ payment requirements');
  return { response: r, requirements: reqs };
}

function hex32Random() {
  const bytes = new Uint8Array(32);
  crypto.getRandomValues(bytes);
  return '0x' + Array.from(bytes).map(b => b.toString(16).padStart(2,'0')).join('');
}

async function ensureWalletOnGateLayer() {
  if (!window.ethereum) throw new Error('æœªæ£€æµ‹åˆ° EVM é’±åŒ…ï¼ˆä¾‹å¦‚ MetaMask/Coinbase Walletï¼‰');
  log('â†’ æ£€æŸ¥é’±åŒ…ç¯å¢ƒâ€¦');
  const chainIdHex = '0x2778'; // Gate Layer Chain ID: 10088

  const current = await ethereum.request({ method: 'eth_chainId' }).catch(() => '0x0');
  log('   å½“å‰ ChainIdï¼š', current);
  if (current !== chainIdHex) {
    try {
      log('   æ­£åœ¨åˆ‡æ¢åˆ° Gate Layerâ€¦');
      await walletRequestWithGracefulError(async () => {
        return await ethereum.request({ method: 'wallet_switchEthereumChain', params: [{ chainId: chainIdHex }] });
      });
      log('   âœ… å·²åˆ‡æ¢è‡³ Gate Layer');
    } catch (e) {
      if (e?.code === 4902) {
        log('   æœªæ‰¾åˆ° Gate Layerï¼Œå°è¯•æ·»åŠ ç½‘ç»œâ€¦');
        await walletRequestWithGracefulError(async () => {
          return await ethereum.request({
            method: 'wallet_addEthereumChain',
            params: [{
              chainId: '0x2778',
              chainName: 'Gate Layer',
              rpcUrls: ['https://gatelayer-mainnet.gatenode.cc/'],
              nativeCurrency: { name: 'Gate Token', symbol: 'GT', decimals: 18 },
              blockExplorerUrls: ['https://www.gatescan.org/gatelayer']
            }]
          });
        });
        log('   âœ… å·²æ·»åŠ  Gate Layer ç½‘ç»œ');
      } else if (e?.code === 4001) {
        const msg = handleWalletError(e, 'ç½‘ç»œåˆ‡æ¢');
        log('   âš ï¸ ' + msg);
        throw new Error(msg);
      } else {
        throw e;
      }
    }
  }

  try {
    log('   æ­£åœ¨è¯·æ±‚è¿æ¥é’±åŒ…â€¦ï¼ˆè¯·åœ¨é’±åŒ…å¼¹çª—ä¸­ç¡®è®¤ï¼‰');
    const accounts = await walletRequestWithGracefulError(async () => {
      return await ethereum.request({ method: 'eth_requestAccounts' });
    }, 'è¿æ¥');
    const from = accounts[0];
    if (!from) throw new Error('æœªè·å–åˆ°é’±åŒ…åœ°å€');
    log('   âœ… å·²è¿æ¥è´¦æˆ·ï¼š', from);
    if (from.toLowerCase() === userWallet.toLowerCase()) {
      log('   â„¹ï¸ æ£€æµ‹åˆ°æ‚¨çš„ä¸ªäººé’±åŒ…åœ°å€ï¼š', userWallet);
    }
    return from;
  } catch (e) {
    const msg = handleWalletError(e, 'é’±åŒ…è¿æ¥');
    log('   âš ï¸ ' + msg);
    throw new Error(msg);
  }
}

function buildTypedData(reqs, from, nowSec) {
  const fallbackTimeout = 30;
  const maxTimeout = Number(reqs.maxTimeoutSeconds || fallbackTimeout);
  const validAfter = String(Math.max(0, nowSec - 60));
  const validBefore = String(nowSec + maxTimeout);

  const message = {
    from,
    to: reqs.payTo,
    value: reqs.maxAmountRequired || reqs.maxAmount || '1000000000000000000', // é»˜è®¤1 GDOGï¼ˆå‡è®¾18ä½å°æ•°ï¼‰
    validAfter,
    validBefore,
    nonce: hex32Random(),
  };

  const typed = {
    types: {
      EIP712Domain: [
        { name: "name", type: "string" },
        { name: "version", type: "string" },
        { name: "chainId", type: "uint256" },
        { name: "verifyingContract", type: "address" },
      ],
      TransferWithAuthorization: [
        { name: "from", type: "address" },
        { name: "to", type: "address" },
        { name: "value", type: "uint256" },
        { name: "validAfter", type: "uint256" },
        { name: "validBefore", type: "uint256" },
        { name: "nonce", type: "bytes32" },
      ],
    },
    primaryType: "TransferWithAuthorization",
    domain: {
      name: reqs.extra?.name || "GDOG",
      version: reqs.extra?.version || "2",
      chainId: 10088,
      verifyingContract: reqs.asset || '0xf6d9cf57e20ba0d33372e8998a9424aa53411e04',
    },
    message,
  };
  return { typed, message };
}

async function createPaymentHeader(reqs) {
  const from = await ensureWalletOnGateLayer();
  log('âœ… é’±åŒ…åœ°å€ï¼š', from);

  const nowSec = Math.floor(Date.now() / 1000);
  const { typed, message } = buildTypedData(reqs, from, nowSec);
  log('â†’ æ„å»º EIP-712 æ•°æ®â€¦');
  log('   æˆæƒæ‘˜è¦ï¼š', JSON.stringify(message));

  try {
    log('â†’ è¯·æ±‚ç­¾åâ€¦ï¼ˆè¯·åœ¨é’±åŒ…å¼¹çª—ä¸­ç¡®è®¤ç­¾åï¼‰');
    const signFn = async () => {
      return await ethereum.request({
        method: 'eth_signTypedData_v4',
        params: [from, JSON.stringify(typed)],
      });
    };
    const signature = await walletRequestWithGracefulError(signFn, 'ç­¾å');
    log('âœ… å·²å®Œæˆ EIPâ€‘712 ç­¾å');

    const paymentPayload = {
      x402Version: 1,
      scheme: reqs.scheme,
      network: 'gate-layer',
      payload: {
        signature,
        authorization: message,
      },
    };

    const b64 = btoa(JSON.stringify(paymentPayload));
    log('   X-PAYMENT (base64) å‰ 60 å­—ç¬¦ï¼š', b64.slice(0, 60) + 'â€¦');
    return b64;
  } catch (e) {
    const msg = handleWalletError(e, 'ç­¾å');
    log('   âš ï¸ ' + msg);
    throw new Error(msg);
  }
}

async function unlock() {
  const originalButtonText = unlockButton ? unlockButton.textContent : '';
  let isSuccess = false;

  try {
    if (unlockButton) {
      unlockButton.disabled = true;
      unlockButton.textContent = 'â³ æ­£åœ¨å¤„ç†...';
    }

    log('â†’ è¯·æ±‚å—ä¿æŠ¤èµ„æºâ€¦');
    const { response, requirements } = await fetchPaymentRequirements();
    if (response.status !== 402) {
      const body = await response.text();
      log('âš ï¸ æœªè¿”å› 402ï¼Œç›´æ¥å¾—åˆ°ï¼š', body.slice(0, 200));
      return;
    }
    log('ğŸ’¡ éœ€è¦æ”¯ä»˜ï¼š', JSON.stringify(requirements, null, 2));

    if (unlockButton) {
      unlockButton.textContent = 'â³ è¯·åœ¨é’±åŒ…ä¸­ç¡®è®¤...';
    }

    log('â†’ ç”Ÿæˆå¹¶ç­¾å EIPâ€‘3009 æˆæƒâ€¦');
    const xPaymentB64 = await createPaymentHeader(requirements);

    if (unlockButton) {
      unlockButton.textContent = 'â³ æ­£åœ¨ç»“ç®—...';
    }

    log('â†’ æºå¸¦ Xâ€‘PAYMENT é‡è¯•â€¦');
    const paid = await fetch('/content', { headers: { 'X-PAYMENT': xPaymentB64 } });
    log('â† æ”¯ä»˜åå“åº”çŠ¶æ€ï¼š', paid.status);

    if (paid.status !== 200) {
      const text = await paid.text();
      log('âŒ æ”¯ä»˜åä»æœªæˆåŠŸï¼š', paid.status, text.slice(0, 300));
      try {
        const parsed = JSON.parse(text);
        if (parsed.error) {
          log('   å¤±è´¥åŸå› ï¼š', parsed.error);
        }
      } catch (_) {}
      alert('æ”¯ä»˜æˆ–ç»“ç®—å¤±è´¥ï¼š' + text.slice(0, 200));
      return;
    }

    const text = await paid.text();
    const xpr = paid.headers.get('x-payment-response');
    log('âœ… å·²è§£é”ï¼š\n' + text);
    if (xpr) {
      const settlement = JSON.parse(atob(xpr));
      log('ğŸ§¾ ç»“ç®—ä¿¡æ¯ï¼š\n' + JSON.stringify(settlement, null, 2));
      if (settlement.txHash) {
        log('ğŸ”— Tx: ' + settlement.txHash);
        log('ğŸ”— æŸ¥çœ‹äº¤æ˜“ï¼šhttps://www.gatescan.org/gatelayer/tx/' + settlement.txHash);
      }
    }
    const lines = text.split('\n');
    if (premiumLine && lines[1]) {
      premiumLine.textContent = lines[1];
      premiumLine.classList.remove('muted');
    }

    isSuccess = true;
    if (unlockButton) {
      unlockButton.disabled = true;
      unlockButton.textContent = 'âœ… å·²è§£é”';
    }
    alert('è§£é”æˆåŠŸï¼\n\n' + text);
  } catch (e) {
    console.error(e);
    const errorMsg = e.message || String(e);
    log('âŒ å‡ºé”™ï¼š', errorMsg);
    const isUserCancellation = errorMsg.includes('å–æ¶ˆ') || errorMsg.includes('æ‹’ç»');
    if (!isUserCancellation) {
      alert('å‡ºé”™ï¼š' + errorMsg);
    } else {
      log('ğŸ’¡ æ“ä½œå·²å–æ¶ˆï¼Œæ‚¨å¯ä»¥é‡æ–°ç‚¹å‡»æŒ‰é’®é‡è¯•');
    }
  } finally {
    if (!isSuccess && unlockButton) {
      unlockButton.disabled = false;
      unlockButton.textContent = originalButtonText;
    }
  }
}

if (unlockButton) {
  unlockButton.addEventListener('click', unlock);
}
</script>
  <script defer src="https://static.cloudflareinsights.com/beacon.min.js/vcd15cbe7772f49c399c6a5babf22c1241717689176015" integrity="sha512-ZpsOmlRQV6y907TI0dKBHq9Md29nnaEIPlkf84rnaERnq6zvWvPUqr2ft8M1aS28oN72PdrCzSjY4U6VaAw1EQ==" data-cf-beacon='{"version":"2024.11.0","token":"5350441611fa4c4aa9f34d1ab0e94507","r":1,"server_timing":{"name":{"cfCacheStatus":true,"cfEdge":true,"cfExtPri":true,"cfL4":true,"cfOrigin":true,"cfSpeedBrain":true},"location_startswith":null}}' crossorigin="anonymous"></script>
</body>
</html>
